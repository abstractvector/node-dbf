// Generated by CoffeeScript 1.7.1
(function() {
  var EventEmitter, Header, Parser, fs,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  EventEmitter = require('events').EventEmitter;

  Header = require('./header');

  fs = require('fs');

  Parser = (function(_super) {
    __extends(Parser, _super);

    function Parser(filename) {
      this.filename = filename;
      this.parseField = __bind(this.parseField, this);
      this.parseRecord = __bind(this.parseRecord, this);
      this.resume = __bind(this.resume, this);
      this.pause = __bind(this.pause, this);
      this.parse = __bind(this.parse, this);
    }

    Parser.prototype.parse = function() {
      this.emit('start', this);
      this.header = new Header(this.filename);
      this.header.parse((function(_this) {
        return function(err) {
          var bufLoc, loc, overflow, sequenceNumber, stream;
          _this.emit('header', _this.header);
          sequenceNumber = 0;
          loc = _this.header.start;
          bufLoc = _this.header.start;
          overflow = null;
          _this.paused = false;
          stream = fs.createReadStream(_this.filename);
          _this.readBuf = function() {
            var buffer;
            if (_this.paused) {
              _this.emit('paused');
              return;
            }
            while (buffer = stream.read()) {
              if (bufLoc !== _this.header.start) {
                bufLoc = 0;
              }
              if (overflow !== null) {
                buffer = overflow + buffer;
              }
              while (loc < (_this.header.start + _this.header.numberOfRecords * _this.header.recordLength) && (bufLoc + _this.header.recordLength) <= buffer.length) {
                _this.emit('record', _this.parseRecord(++sequenceNumber, buffer.slice(bufLoc, bufLoc += _this.header.recordLength)));
              }
              loc += bufLoc;
              if (bufLoc < buffer.length) {
                overflow = buffer.slice(bufLoc, buffer.length);
              } else {
                overflow = null;
              }
              return _this;
            }
          };
          stream.on('readable', _this.readBuf);
          return stream.on('end', function() {
            return _this.emit('end');
          });
        };
      })(this));
      return this;
    };

    Parser.prototype.pause = function() {
      return this.paused = true;
    };

    Parser.prototype.resume = function() {
      this.paused = false;
      this.emit('resuming');
      return this.readBuf();
    };

    Parser.prototype.parseRecord = function(sequenceNumber, buffer) {
      var field, loc, record, _fn, _i, _len, _ref;
      record = {
        '@sequenceNumber': sequenceNumber,
        '@deleted': (buffer.slice(0, 1))[0] !== 32
      };
      loc = 1;
      _ref = this.header.fields;
      _fn = (function(_this) {
        return function(field) {
          return record[field.name] = _this.parseField(field, buffer.slice(loc, loc += field.length));
        };
      })(this);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        field = _ref[_i];
        _fn(field);
      }
      return record;
    };

    Parser.prototype.parseField = function(field, buffer) {
      var value;
      value = (buffer.toString('utf-8')).replace(/^\x20+|\x20+$/g, '');
      if (field.type === 'N') {
        value = value === +value && value === (value|0) ? parseInt(value) : parseFloat(value, 10);
      }
      return value;
    };

    return Parser;

  })(EventEmitter);

  module.exports = Parser;

}).call(this);
